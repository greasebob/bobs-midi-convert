# -*- coding: utf-8 -*-
"""Bob's Midi Convert.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YNebID6yrtsqjCnXO5feFrG8LpLJqUR1
"""

# -*- coding: utf-8 -*-
"""Audio to MIDI Converter - Full Featured Edition
Transform any audio into MIDI with advanced piano transcription
Supports YouTube downloads, batch processing, and cookie authentication
"""

#!/usr/bin/env python
import sys
import subprocess
import importlib
import logging
import os
import re
import shutil
import tempfile
import time
import numpy as np
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import zipfile

# --------------- Package Installation ---------------

REQUIRED_PACKAGES: Dict[str, str] = {
    'ffmpeg': 'ffmpeg-python',
    'piano_transcription_inference': 'piano-transcription-inference',
    'transkun': 'transkun',
    'yt_dlp': 'yt-dlp',
    'librosa': 'librosa',
    'torch': 'torch',
    'tqdm': 'tqdm',
    'pretty_midi': 'pretty-midi',
    'unidecode': 'Unidecode',
}

def check_and_install_packages(packages: Dict[str, str]) -> None:
    """Check if required packages are installed and install any missing ones."""
    missing_packages = []
    for module_name, package_name in packages.items():
        try:
            importlib.import_module(module_name)
        except ImportError:
            missing_packages.append(package_name)
    if missing_packages:
        print("üì¶ Installing missing packages...")
        print("‚è±Ô∏è  This may take a few minutes, especially for ffmpeg-python and torch...")
        for pkg in missing_packages:
            try:
                print(f"\n   üì• Installing {pkg}...")
                # Remove -q flag to show progress
                result = subprocess.run(
                    [sys.executable, '-m', 'pip', 'install', pkg],
                    timeout=600,  # 10 minute timeout
                    capture_output=False,  # Show output in real-time
                    text=True
                )
                if result.returncode == 0:
                    print(f"   ‚úÖ {pkg} installed successfully")
                else:
                    print(f"   ‚ö†Ô∏è {pkg} installation returned code {result.returncode}")
            except subprocess.TimeoutExpired:
                print(f"   ‚è∞ Timeout installing {pkg} - it may be too large or network is slow")
                print(f"   üí° Try running: !pip install {pkg}")
                raise
            except subprocess.CalledProcessError as e:
                print(f"   ‚ö†Ô∏è Failed to install {pkg}: {e}")
                raise
        print("\n‚úÖ All packages installed successfully!")


check_and_install_packages(REQUIRED_PACKAGES)

# --------------- Imports ---------------

import torch
import librosa
import ffmpeg
import yt_dlp
from piano_transcription_inference import PianoTranscription, sample_rate as piano_sample_rate
import transkun
from tqdm.notebook import tqdm
from IPython.display import display, clear_output, HTML, Javascript
from google.colab import files, output
import pretty_midi
from unidecode import unidecode

# --------------- Output Redirection (Console ‚Üí Processing Log) ---------------

class OutputRedirector:
    """Redirects print/console output to the JavaScript Processing Log."""
    def __init__(self):
        self.original_stdout = sys.stdout

    def write(self, text):
        if text.strip():
            clean_text = text.replace('\n', '').replace('\r', '').strip()
            if clean_text:
                try:
                    display(Javascript(f'updateProgress({repr(clean_text)})'))
                except:
                    pass
        return len(text)

    def flush(self):
        pass

output_redirector = OutputRedirector()


# --------------- Core Converter Class ---------------

class AudioToMidiConverter:
    """Handles audio to MIDI conversion using piano transcription."""

    def __init__(self):
        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        self.piano_transcriptor = None
        self.temp_files = []
        self.cookie_file = None

    def load_piano_model(self):
        """Load the piano transcription model."""
        if self.piano_transcriptor is None:
            print("üéπ Loading Piano Transcription model...")
            self.piano_transcriptor = PianoTranscription(device=self.device)
            print("‚úÖ Model loaded!")

    def set_cookie_file(self, cookie_path: str):
        """Set the cookie file for YouTube downloads."""
        self.cookie_file = cookie_path

    def sanitize_filename(self, filename: str) -> str:
        """Sanitize filename to be filesystem-safe."""
        filename = unidecode(filename)
        filename = re.sub(r'[^\w\s-]', '', filename)
        filename = re.sub(r'[-\s]+', '_', filename)
        return filename[:200]

    def download_youtube_audio(self, url: str, output_dir: Path) -> Optional[Path]:
        """Download audio from YouTube URL."""
        try:
            display(Javascript(f'updateProgress("üì• Downloading from YouTube: {url[:50]}...")'))

            ydl_opts = {
                'format': 'bestaudio/best',
                'outtmpl': str(output_dir / '%(title)s.%(ext)s'),
                'postprocessors': [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '192',
                }],
                'quiet': True,
                'no_warnings': True,
            }

            # Add cookie file if available
            if self.cookie_file and Path(self.cookie_file).exists():
                ydl_opts['cookiefile'] = self.cookie_file
                display(Javascript('updateProgress("üç™ Using cookie file for authentication")'))

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                title = info.get('title', 'download')
                sanitized_title = self.sanitize_filename(title)

                # Wait briefly for post-processor to finish
                time.sleep(1)

                # Strategy 1: Check with sanitized title first
                for ext in ['.mp3', '.m4a', '.webm', '.opus', '.wav']:
                    possible_path = output_dir / f"{sanitized_title}{ext}"
                    if possible_path.exists():
                        self.temp_files.append(possible_path)
                        display(Javascript(f'updateProgress("‚úÖ Downloaded: {sanitized_title}")'))
                        return possible_path

                # Strategy 2: Check with original title
                for ext in ['.mp3', '.m4a', '.webm', '.opus', '.wav']:
                    possible_path = output_dir / f"{title}{ext}"
                    if possible_path.exists():
                        final_path = output_dir / f"{sanitized_title}{ext}"
                        if possible_path != final_path:
                            possible_path.rename(final_path)
                        self.temp_files.append(final_path)
                        display(Javascript(f'updateProgress("‚úÖ Downloaded: {sanitized_title}")'))
                        return final_path

                # Strategy 3: Find ANY recently created audio file
                current_time = time.time()
                for file_path in output_dir.glob('*'):
                    if file_path.suffix.lower() in ['.mp3', '.m4a', '.webm', '.opus', '.wav']:
                        # Check if file was created in the last 60 seconds
                        if current_time - file_path.stat().st_mtime < 60:
                            final_path = output_dir / f"{sanitized_title}{file_path.suffix}"
                            if file_path != final_path:
                                file_path.rename(final_path)
                            self.temp_files.append(final_path)
                            display(Javascript(f'updateProgress("‚úÖ Downloaded: {sanitized_title}")'))
                            return final_path

            display(Javascript('updateProgress("‚ùå Download failed - could not locate file", "error")'))
            return None

        except Exception as e:
            display(Javascript(f'updateProgress("‚ùå YouTube download error: {str(e)}", "error")'))
            return None

    def trim_audio(self, input_path: Path, output_path: Path,
                   start_time: float, end_time: Optional[float] = None):
        """Trim audio file to specified time range."""
        try:
            stream = ffmpeg.input(str(input_path), ss=start_time)
            if end_time and end_time > 0:
                stream = stream.output(str(output_path), t=end_time - start_time)
            else:
                stream = stream.output(str(output_path))
            ffmpeg.run(stream, overwrite_output=True, quiet=True)
            self.temp_files.append(output_path)
        except Exception as e:
            raise RuntimeError(f"Audio trimming failed: {e}")

    def convert_with_piano_transcription(self, audio_path: Path, midi_path: Path,
                                         max_duration: Optional[float] = 0.2, cancel_flag: List = None) -> bool:
        """Convert audio to MIDI using Piano Transcription model."""
        try:
            if cancel_flag and cancel_flag[0]:
                return False

            self.load_piano_model()

            # Load audio
            display(Javascript(f'updateProgress("üìÇ Loading audio: {audio_path.name}")'))
            audio, sr = librosa.load(str(audio_path), sr=piano_sample_rate, mono=True)

            if cancel_flag and cancel_flag[0]:
                return False

            # Transcribe
            display(Javascript('updateProgress("üéº Transcribing audio to MIDI...")'))
            transcribed_dict = self.piano_transcriptor.transcribe(audio, str(midi_path))

            if cancel_flag and cancel_flag[0]:
                return False

            # Apply max note duration filter if specified
            if max_duration is not None:
                midi_data = pretty_midi.PrettyMIDI(str(midi_path))
                filtered_notes = []

                for instrument in midi_data.instruments:
                    for note in instrument.notes:
                        note_duration = note.end - note.start
                        if note_duration <= max_duration:
                            filtered_notes.append(note)

                # Create new MIDI with filtered notes
                new_midi = pretty_midi.PrettyMIDI()
                new_instrument = pretty_midi.Instrument(program=0)
                new_instrument.notes = filtered_notes
                new_midi.instruments.append(new_instrument)
                new_midi.write(str(midi_path))

                display(Javascript(f'updateProgress("üéµ Filtered to {len(filtered_notes)} notes")'))

            if midi_path.exists():
                display(Javascript(f'updateProgress("‚úÖ MIDI saved: {midi_path.name}")'))
                return True
            return False

        except Exception as e:
            display(Javascript(f'updateProgress("‚ùå Error: {str(e)}", "error")'))
            return False

    def convert_with_transkun(self, audio_path: Path, midi_path: Path, cancel_flag: List = None) -> bool:
        """Convert audio to MIDI using Transkun."""
        try:
            if cancel_flag and cancel_flag[0]:
                return False

            display(Javascript('updateProgress("üéº Transcribing with Transkun...")'))

            cmd = [
                'transkun',
                str(audio_path),
                '-o', str(midi_path)
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if cancel_flag and cancel_flag[0]:
                return False

            if result.returncode == 0 and midi_path.exists():
                display(Javascript(f'updateProgress("‚úÖ MIDI saved: {midi_path.name}")'))
                return True
            else:
                display(Javascript(f'updateProgress("‚ùå Transkun error: {result.stderr}", "error")'))
                return False

        except Exception as e:
            display(Javascript(f'updateProgress("‚ùå Error: {str(e)}", "error")'))
            return False

    def cleanup_temp_files(self):
        """Clean up temporary files."""
        for temp_file in self.temp_files:
            try:
                if temp_file.exists():
                    temp_file.unlink()
            except:
                pass
        self.temp_files = []

# --------------- Global State ---------------

converter = AudioToMidiConverter()
uploaded_files = {}
cancel_conversion = [False]
output_midi_paths = []

# --------------- Conversion Handler ---------------

def run_conversion(settings):
    """Main conversion handler called from JavaScript."""
    global uploaded_files, output_midi_paths, converter, cancel_conversion

    # Initial log BEFORE redirecting stdout
    display(Javascript('updateProgress("‚úÖ Conversion function started!")'))

    # Redirect console output to Processing Log
    original_stdout = sys.stdout
    sys.stdout = output_redirector

    try:
        # Reset state
        cancel_conversion[0] = False
        output_midi_paths = []

        # Get settings
        youtube_urls = settings.get('youtubeUrls', '').strip()
        custom_title = settings.get('customTitle', '')
        custom_file_names = settings.get('customFileNames', [])
        model_choice = settings.get('modelChoice', 'piano')
        chunk_dur = float(settings.get('chunkDur', 10))
        max_notes = float(settings.get('maxNotes', 0.2))
        enable_max_notes = settings.get('enableMaxNotes', True)
        start_time = float(settings.get('startTime', 0))
        end_time = float(settings.get('endTime', 0))
        zip_output = settings.get('zipOutput', False)
        zip_filename = settings.get('zipFilename', 'midi_files')
        keep_mp3 = settings.get('keepMp3', False)
        include_mp3 = settings.get('includeMp3', False)

        print("üîß Testing output redirection - if you see this, redirection works!")
        display(Javascript('updateProgress("üìã Settings loaded successfully")'))


        # Prepare output
        output_dir = Path("./midi_output")
        output_dir.mkdir(exist_ok=True)

        audio_files = []

        # Handle YouTube URLs (can be multiple)
        if youtube_urls:
            url_list = [u.strip() for u in youtube_urls.split('\n') if u.strip()]
            display(Javascript(f'updateProgress("üé¨ Found {len(url_list)} YouTube URL(s)")'))

            for idx, url in enumerate(url_list):
                if cancel_conversion[0]:
                    break

                display(Javascript(f'updateProgress("üì• Downloading {idx+1}/{len(url_list)}...")'))
                audio_path = converter.download_youtube_audio(url, output_dir)
                if audio_path:
                    audio_files.append(audio_path)

        # Handle uploaded files (can be multiple)
        if uploaded_files:
            display(Javascript(f'updateProgress("üìÅ Found {len(uploaded_files)} uploaded file(s)")'))
            for filename in uploaded_files.keys():
                audio_files.append(Path(filename))

        if not audio_files:
            display(Javascript('updateProgress("‚ùå No audio sources provided!", "error")'))
            return

        # Process each audio file
        total_files = len(audio_files)
        results = []
        audio_file_paths = []

        for idx, audio_path in enumerate(audio_files):
            if cancel_conversion[0]:
                display(Javascript('updateProgress("üõë Conversion cancelled by user", "warning")'))
                break

            display(Javascript(f'updateProgress("üéµ Processing {idx+1}/{total_files}: {audio_path.name}")'))
            display(Javascript(f'updateOverallProgress({idx}, {total_files})'))

            try:
                # Handle trimming if needed
                if start_time > 0 or end_time > 0:
                    display(Javascript(f'updateProgress("‚úÇÔ∏è Trimming audio ({start_time}s to {end_time if end_time > 0 else "end"}s)")'))
                    trimmed_path = output_dir / f"trimmed_{audio_path.name}"
                    converter.trim_audio(audio_path, trimmed_path, start_time, end_time if end_time > 0 else None)
                    audio_path = trimmed_path

                # Store audio file path for potential inclusion in ZIP
                audio_file_paths.append(audio_path)

                # Determine output filename
                if custom_file_names and idx < len(custom_file_names) and custom_file_names[idx]:
                    # Use custom name from the array if provided
                    midi_filename = converter.sanitize_filename(custom_file_names[idx]) + ".mid"
                elif custom_title and total_files == 1:
                    midi_filename = converter.sanitize_filename(custom_title) + ".mid"
                elif custom_title and total_files > 1:
                    midi_filename = f"{converter.sanitize_filename(custom_title)}_{idx+1}.mid"
                else:
                    midi_filename = audio_path.stem + ".mid"

                midi_path = output_dir / midi_filename

                # Convert using selected model
                display(Javascript('updateProgress("üéµ Converting to MIDI...")'))

                if model_choice == 'transkun':
                    success = converter.convert_with_transkun(audio_path, midi_path, cancel_conversion)
                else:
                    # Only apply max_notes filter if enabled
                    max_duration = max_notes if enable_max_notes else None
                    success = converter.convert_with_piano_transcription(
                        audio_path, midi_path, max_duration, cancel_conversion
                    )

                if success and not cancel_conversion[0]:
                    results.append(midi_path)
                    display(Javascript(f'updateProgress("‚úÖ Completed: {midi_filename}")'))

            except Exception as e:
                display(Javascript(f'updateProgress("‚ùå Failed: {audio_path.name} - {str(e)}", "error")'))

            # Update progress
            display(Javascript(f'updateOverallProgress({idx+1}, {total_files})'))

        # Handle outputs
        if results:
            output_midi_paths = results

            if len(results) == 1:
                # Single file
                if include_mp3 and audio_file_paths:
                    # Include the audio file for download as well
                    output_midi_paths.append(audio_file_paths[0])
                    display(Javascript(f'onConversionComplete("{results[0].name}", false)'))
                else:
                    display(Javascript(f'onConversionComplete("{results[0].name}", false)'))
            else:
                # Multiple files
                if zip_output:
                    # Sanitize zip filename
                    sanitized_zip_name = converter.sanitize_filename(zip_filename)
                    if not sanitized_zip_name:
                        sanitized_zip_name = "midi_files"

                    zip_path = output_dir / f"{sanitized_zip_name}.zip"

                    # Create zip
                    with zipfile.ZipFile(str(zip_path), 'w') as zipf:
                        # Add MIDI files
                        for midi_file in results:
                            zipf.write(str(midi_file), arcname=midi_file.name)

                        # Add MP3 files if requested
                        if include_mp3:
                            display(Javascript('updateProgress("üì¶ Including MP3 files in ZIP...")'))
                            for audio_file in audio_file_paths:
                                if audio_file.exists() and audio_file.suffix in ['.mp3', '.m4a', '.webm', '.opus']:
                                    zipf.write(str(audio_file), arcname=audio_file.name)
                            display(Javascript('updateProgress("‚úÖ MP3 files added to ZIP")'))

                    output_midi_paths = [zip_path]
                    display(Javascript(f'onConversionComplete("{sanitized_zip_name}.zip", true)'))
                else:
                    # Not zipped - multiple separate files
                    if include_mp3:
                        # Add audio files to output list
                        for audio_file in audio_file_paths:
                            if audio_file.exists():
                                output_midi_paths.append(audio_file)
                    display(Javascript(f'onConversionComplete("multiple", false)'))

        # Cleanup
        if not keep_mp3 and not include_mp3:
            converter.cleanup_temp_files()
        else:
            display(Javascript('updateProgress("üíæ Keeping downloaded audio files")'))

    except Exception as e:
        error_msg = f"Python error: {str(e)}"
        print(f"ERROR: {error_msg}")  # This will go to Colab console
        display(Javascript(f'onConversionError("{error_msg}")'))
        import traceback
        traceback.print_exc()  # Print full traceback to Colab console

    finally:
        # Restore original stdout
        sys.stdout = original_stdout

def cancel_conversion_handler():
    """Handle cancellation request."""
    global cancel_conversion
    cancel_conversion[0] = True
    display(Javascript('updateProgress("üõë Cancelling conversion...", "warning")'))
    # Tell JavaScript to reset UI state
    display(Javascript('''
        setTimeout(() => {
            onConversionCancelled();
        }, 500);
    '''))

def download_midi_file():
    """Download the generated MIDI file(s)."""
    global output_midi_paths
    try:
        if not output_midi_paths:
            display(Javascript('updateProgress("‚ùå No MIDI files to download", "error")'))
            return

        display(Javascript('updateProgress("‚¨áÔ∏è Downloading files...")'))
        for midi_path in output_midi_paths:
            if midi_path.exists():
                files.download(str(midi_path))

    except Exception as e:
        display(Javascript(f'updateProgress("‚ùå Download error: {str(e)}", "error")'))

def fetch_youtube_titles(urls):
    """Fetch titles for YouTube URLs."""
    titles = []
    for url in urls:
        try:
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'skip_download': True,
            }

            # Add cookie file if available
            if converter.cookie_file and Path(converter.cookie_file).exists():
                ydl_opts['cookiefile'] = converter.cookie_file

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                title = info.get('title', 'Unknown Title')
                titles.append(title)
        except Exception as e:
            titles.append(f'Unable to fetch title')

    return titles
# --------------- UI Display ---------------

def show_ui():
    """Display the full HTML page UI."""
    clear_output(wait=True)

    html_content = r"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>YouTube to MIDI Converter</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            html, body {
                height: 100%;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                background: #0f172a;
                color: #e2e8f0;
            }

            .container {
                max-width: 1000px;
                margin: 0 auto;
                padding: 40px 20px;
            }

            .header {
                text-align: center;
                margin-bottom: 50px;
                color: #f1f5f9;
            }

            .header h1 {
                font-size: 3.5em;
                font-weight: 800;
                margin-bottom: 15px;
                background: linear-gradient(135deg, #818cf8 0%, #c084fc 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }

            .tip-banner {
                background: #1e293b;
                border: 1px solid #334155;
                border-radius: 12px;
                padding: 16px;
                margin-bottom: 25px;
                text-align: center;
                font-size: 0.95em;
                color: #94a3b8;
            }

            .tip-banner strong {
                color: #e2e8f0;
            }

            .card {
                background: #1e293b;
                padding: 30px;
                border-radius: 16px;
                margin-bottom: 25px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid #334155;
            }

            .card-title, .card-title-with-info {
                font-size: 1.2em;
                font-weight: 700;
                margin-bottom: 20px;
                color: #f1f5f9;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .label-with-info {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .info-icon {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 18px;
                height: 18px;
                background: #334155;
                color: #94a3b8;
                border-radius: 50%;
                font-size: 12px;
                font-weight: bold;
                cursor: help;
                position: relative;
            }

            .info-icon:hover {
                background: #475569;
                color: #cbd5e1;
            }

            .info-icon:hover .info-tooltip {
                display: block;
            }

            .info-tooltip {
                display: none;
                position: absolute;
                bottom: 125%;
                left: 50%;
                transform: translateX(-50%);
                background: #1e293b;
                border: 1px solid #475569;
                color: #e2e8f0;
                padding: 10px 14px;
                border-radius: 8px;
                font-size: 0.85em;
                white-space: nowrap;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                z-index: 1000;
                font-weight: normal;
            }

            textarea, input[type="text"], input[type="number"], select {
                width: 100%;
                padding: 12px 16px;
                border: 2px solid #334155;
                background: #0f172a;
                border-radius: 10px;
                color: #f1f5f9;
                font-size: 0.95em;
                font-family: 'Inter', sans-serif;
                transition: all 0.2s;
            }

            textarea:focus, input:focus, select:focus {
                outline: none;
                border-color: #6366f1;
                background: #1e293b;
                box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            }

            input[type="number"]:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                background: #0a0f1a;
                border-color: #1e293b;
            }

            select {
                cursor: pointer;
            }

            textarea {
                resize: vertical;
                min-height: 100px;
            }

            label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #cbd5e1;
                font-size: 0.9em;
            }

            .hint {
                color: #94a3b8;
                font-size: 0.85em;
                margin-top: 8px;
            }

            .upload-zone {
                border: 2px dashed #475569;
                border-radius: 14px;
                padding: 50px 30px;
                text-align: center;
                cursor: pointer;
                transition: all 0.3s;
                background: #0f172a;
            }

            .upload-zone:hover {
                border-color: #818cf8;
                background: #1e293b;
            }

            .upload-zone .icon {
                font-size: 3.5em;
                margin-bottom: 15px;
                opacity: 0.8;
            }

            .upload-zone h3 {
                font-size: 1.3em;
                color: #f1f5f9;
                margin-bottom: 8px;
                display: inline-flex;
                align-items: center;
                gap: 8px;
            }

            .upload-zone p {
                color: #94a3b8;
            }

            .file-info {
                margin-top: 20px;
                padding: 14px;
                background: #312e81;
                border-radius: 8px;
                color: #c7d2fe;
                font-weight: 500;
                display: none;
                border: 1px solid #4c1d95;
            }

            .settings-grid-full {
                display: flex;
                flex-direction: column;
                gap: 18px;
                margin-top: 18px;
                margin-bottom: 24px;
            }

            .settings-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin-bottom: 16px;
            }

            .form-group {
                display: flex;
                flex-direction: column;
            }

            .checkbox-wrapper {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 14px 16px;
                background: #0f172a;
                border-radius: 10px;
                margin-top: 12px;
                transition: background 0.2s;
                border: 1px solid #334155;
            }

            .checkbox-wrapper:hover {
                background: #1e293b;
                border-color: #475569;
            }

            .checkbox-wrapper input[type="checkbox"] {
                width: 20px;
                height: 20px;
                cursor: pointer;
                accent-color: #6366f1;
            }

            .checkbox-wrapper input[type="checkbox"]:disabled {
                cursor: not-allowed;
                opacity: 0.5;
            }

            .checkbox-wrapper.disabled {
                opacity: 0.6;
            }

            .checkbox-wrapper.disabled label {
                cursor: not-allowed;
            }

            .checkbox-wrapper label {
                margin: 0;
                cursor: pointer;
                font-weight: 500;
                color: #e2e8f0;
                font-size: 0.95em;
                display: flex;
                align-items: center;
            }

            .zip-filename-input {
                margin-top: 12px;
                padding-left: 32px;
                display: none;
            }

            .zip-filename-input.visible {
                display: block;
            }

            .file-naming-section {
                margin-top: 20px;
                padding: 20px;
                background: #0f172a;
                border-radius: 10px;
                border: 1px solid #334155;
            }

            .file-naming-item {
                margin-bottom: 14px;
            }

            .file-naming-item:last-child {
                margin-bottom: 0;
            }

            .file-naming-item label {
                font-size: 0.85em;
                color: #94a3b8;
                margin-bottom: 6px;
                display: block;
            }

            .file-naming-item input::placeholder {
                color: #475569;
                font-style: italic;
            }

            .mp3-include-option {
                margin-top: 12px;
                padding-left: 32px;
                display: none;
            }

            .mp3-include-option.visible {
                display: block;
            }

            .cookie-btn {
                width: 100%;
                padding: 18px;
                background: transparent;
                border: 2px solid #6366f1;
                border-radius: 12px;
                font-size: 1.05em;
                font-weight: 600;
                color: #6366f1;
                cursor: pointer;
                transition: all 0.2s;
            }

            .cookie-btn:hover {
                background: #6366f1;
                color: white;
            }

            .cookie-info {
                margin-top: 12px;
                padding: 12px 16px;
                background: #312e81;
                border-radius: 8px;
                color: #c7d2fe;
                font-weight: 500;
                display: none;
                border: 1px solid #4c1d95;
            }

            .button-group {
                display: grid;
                grid-template-columns: 2fr 1fr;
                gap: 18px;
                margin-bottom: 30px;
            }

            .btn {
                padding: 18px;
                border: none;
                border-radius: 12px;
                font-size: 1.15em;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
                font-family: 'Inter', sans-serif;
            }

            .btn-primary {
                background: #4f46e5;
                color: white;
            }

            .btn-primary:hover:not(:disabled) {
                background: #4338ca;
                transform: translateY(-2px);
            }

            .btn-primary:disabled {
                background: #334155;
                cursor: not-allowed;
                opacity: 0.5;
            }

            .btn-cancel {
                background: #dc2626;
                color: white;
            }

            .btn-cancel:hover:not(:disabled) {
                background: #b91c1c;
                transform: translateY(-2px);
            }

            .btn-cancel:disabled {
                background: #334155;
                cursor: not-allowed;
                opacity: 0.5;
            }

            .progress-section {
                padding: 22px;
                background: #1e293b;
                border-radius: 16px;
                margin-bottom: 25px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                border: 1px solid #334155;
                display: none;
            }

            .progress-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 12px;
            }

            .progress-text {
                font-weight: 600;
                color: #f1f5f9;
            }

            .progress-count {
                color: #94a3b8;
                font-weight: 500;
            }

            .progress-bar-container {
                width: 100%;
                height: 8px;
                background: #0f172a;
                border-radius: 10px;
                overflow: hidden;
            }

            .progress-bar {
                height: 100%;
                background: linear-gradient(90deg, #6366f1 0%, #8b5cf6 100%);
                width: 0%;
                transition: width 0.5s ease;
            }

            .results-section {
                display: none;
            }

            .log-container {
                background: #0a0f1a;
                color: #68d391;
                padding: 20px;
                border-radius: 12px;
                font-family: 'Monaco', 'Courier New', monospace;
                font-size: 0.85em;
                max-height: 320px;
                overflow-y: auto;
                line-height: 1.7;
                box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
                border: 1px solid #1e293b;
            }

            .btn-download {
                margin-top: 18px;
                padding: 16px 35px;
                background: #10b981;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 1.05em;
                font-weight: 700;
                cursor: pointer;
                transition: all 0.2s;
                display: none;
            }

            .btn-download:hover {
                background: #059669;
                transform: translateY(-2px);
            }

            .collapsible-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                cursor: pointer;
                padding: 8px 0;
            }

            .toggle-icon {
                font-size: 1.2em;
                color: #818cf8;
                transition: transform 0.3s;
            }

            .hidden {
                display: none;
            }

            /* Debug Section Styles */
            .debug-btn {
                padding: 6px 12px;
                background: #4a5568;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
                margin-top: 10px;
                transition: all 0.2s;
            }

            .debug-btn:hover {
                background: #5a6678;
            }

            .debug-section {
                display: none;
                margin-top: 15px;
                padding: 15px;
                background: #1a202c;
                border: 1px solid #4a5568;
                border-radius: 8px;
            }

            .debug-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }

            .debug-title {
                margin: 0;
                color: #f7fafc;
                font-size: 14px;
            }

            .debug-refresh-btn {
                padding: 4px 8px;
                background: #2d3748;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 11px;
                transition: all 0.2s;
            }

            .debug-refresh-btn:hover {
                background: #3d4758;
            }

            .debug-output {
                background: #000;
                color: #68d391;
                padding: 12px;
                border-radius: 4px;
                font-size: 11px;
                max-height: 300px;
                overflow-y: auto;
                margin: 0;
                font-family: 'Courier New', monospace;
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            @media (max-width: 768px) {
                .header h1 {
                    font-size: 2.5em;
                }

                .button-group {
                    grid-template-columns: 1fr;
                }

                .settings-grid {
                    grid-template-columns: 1fr;
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>üéµ YouTube to MIDI</h1>

                <!-- Debug Button -->
                <button class="debug-btn" onclick="toggleDebug()">üêõ Debug Info</button>

                <!-- Debug Output Section -->
                <div class="debug-section" id="debugSection">
                    <div class="debug-header">
                        <h3 class="debug-title">üîç Debug Information</h3>
                        <button class="debug-refresh-btn" onclick="refreshDebug()">‚Üª Refresh</button>
                    </div>
                    <pre class="debug-output" id="debugOutput"></pre>
                </div>
            </div>

            <!-- Fullscreen Tip Banner -->
            <div class="tip-banner">
                üí° <strong>Tip:</strong> Click 'Code cell output actions' (top left of output cell) ‚Üí 'View output fullscreen' for best experience
            </div>

            <!-- YouTube URLs -->
            <div class="card">
                <div class="card-title-with-info">
                    üé¨ YouTube URLs
                    <span class="info-icon">i
                        <span class="info-tooltip">Supports individual videos and full playlists</span>
                    </span>
                </div>
                <textarea id="youtubeUrls" placeholder="https://www.youtube.com/watch?v=...
https://www.youtube.com/watch?v=...

Add one URL per line for batch processing"></textarea>
                <div class="hint">Or upload audio files below instead</div>
            </div>

            <!-- File Upload -->
            <div class="card">
                <div class="upload-zone" id="uploadZone">
                    <div class="icon">üìÅ</div>
                    <h3>
                        Drop your audio files here
                        <span class="info-icon">i
                            <span class="info-tooltip">Alternative to YouTube URLs for local audio files</span>
                        </span>
                    </h3>
                    <p>or click to browse ‚Ä¢ MP3, WAV, FLAC, M4A, OGG ‚Ä¢ Multiple files supported</p>
                    <input type="file" id="fileInput" style="display: none;" accept="audio/*" multiple>
                    <div class="file-info" id="fileInfo"></div>
                </div>
            </div>

            <!-- Settings -->
            <div class="card">
                <div class="collapsible-header" onclick="toggleSettings()">
                    <div class="card-title" style="margin: 0;">‚öôÔ∏è Conversion Settings</div>
                    <span class="toggle-icon" id="toggleIcon">‚ñº</span>
                </div>

                <div id="settingsContent">
                    <div class="settings-grid-full">
                        <div class="form-group">
                            <label class="label-with-info">
                                Transcription Model
                                <span class="info-icon">i
                                    <span class="info-tooltip">Piano Transcription is stable and recommended. Transkun is experimental and less accurate.</span>
                                </span>
                            </label>
                            <select id="modelChoice">
                                <option value="piano">Piano Transcription (Recommended)</option>
                                <option value="transkun">Transkun (Experimental - Less Accurate)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Custom Title for Single File -->
                    <div class="form-group">
                        <label class="label-with-info">
                            Custom Output Filename (Optional)
                            <span class="info-icon">i
                                <span class="info-tooltip">Custom name for output MIDI file. Leave blank to use source name. For multiple files, names them sequentially.</span>
                            </span>
                        </label>
                        <input type="text" id="customTitle" placeholder="my_custom_song">
                        <div class="hint">Extension (.mid) will be added automatically</div>
                    </div>

                    <!-- File Naming Section -->
                    <div class="file-naming-section" id="fileNamingSection" style="display: none;">
                        <label class="label-with-info" style="margin-bottom: 12px;">
                            Name each file individually
                            <span class="info-icon">i
                                <span class="info-tooltip">Customize output MIDI filenames. Leave blank to use original names.</span>
                            </span>
                        </label>
                        <div id="fileNamingList"></div>
                    </div>

                    <div class="settings-grid">
                        <div class="form-group">
                            <label class="label-with-info">
                                Chunk Duration (sec)
                                <span class="info-icon">i
                                    <span class="info-tooltip">Audio processing chunk size. Larger = faster but uses more memory</span>
                                </span>
                            </label>
                            <input type="number" id="chunkDur" value="10" min="5" max="60">
                        </div>
                        <div class="form-group">
                            <label class="label-with-info">
                                Max Notes
                                <span class="info-icon">i
                                    <span class="info-tooltip">Maximum note duration filter. Lower values remove sustained notes</span>
                                </span>
                            </label>
                            <input type="number" id="maxNotes" value="0.2" step="0.1" min="0" max="1">
                        </div>
                        <div class="form-group">
                            <label class="label-with-info">
                                Start Time (sec)
                                <span class="info-icon">i
                                    <span class="info-tooltip">Trim audio start point. Leave at 0 to start from beginning</span>
                                </span>
                            </label>
                            <input type="number" id="startTime" value="0" min="0">
                        </div>
                        <div class="form-group">
                            <label class="label-with-info">
                                End Time (sec, 0=full)
                                <span class="info-icon">i
                                    <span class="info-tooltip">Trim audio end point. 0 means process until the end</span>
                                </span>
                            </label>
                            <input type="number" id="endTime" value="0" min="0">
                        </div>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="enableMaxNotes" checked>
                        <label for="enableMaxNotes">
                            Enable Max Note Duration Filter
                            <span class="info-icon">i
                                <span class="info-tooltip">Uncheck to keep all sustained notes without filtering</span>
                            </span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="zipOutput">
                        <label for="zipOutput">
                            üì¶ Package multiple MIDIs into ZIP file
                            <span class="info-icon">i
                                <span class="info-tooltip">Bundle all MIDI files into one ZIP instead of separate downloads</span>
                            </span>
                        </label>
                    </div>

                    <div class="zip-filename-input" id="zipFilenameInput">
                        <div class="form-group">
                            <label class="label-with-info">
                                ZIP Filename
                                <span class="info-icon">i
                                    <span class="info-tooltip">Name for your ZIP file (without .zip extension)</span>
                                </span>
                            </label>
                            <input type="text" id="zipFilename" placeholder="midi_files" value="midi_files">
                        </div>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="keepMp3">
                        <label for="keepMp3">
                            üíæ Save audio files (MP3)
                            <span class="info-icon">i
                                <span class="info-tooltip">Keep the downloaded/converted MP3 files instead of deleting them after MIDI conversion</span>
                            </span>
                        </label>
                    </div>

                    <div class="mp3-include-option" id="mp3IncludeOption">
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="includeMp3">
                            <label for="includeMp3">
                                üéµ Include audio files in download
                                <span class="info-icon">i
                                    <span class="info-tooltip">Download MP3 files alongside MIDI files (in ZIP if zipping, as separate files otherwise)</span>
                                </span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cookie Upload -->
            <div class="card">
                <div class="card-title-with-info">
                    üç™ Cookie File (Optional)
                    <span class="info-icon">i
                        <span class="info-tooltip">Export cookies.txt from your browser using a cookie extension while logged into YouTube</span>
                    </span>
                </div>
                <p class="hint" style="margin-bottom: 15px;">Upload cookies.txt if YouTube blocks downloads or for age-restricted videos</p>
                <input type="file" id="cookieInput" style="display: none;" accept=".txt">
                <button class="cookie-btn" onclick="document.getElementById('cookieInput').click()">
                    üìÑ Upload Cookie File
                </button>
                <div class="cookie-info" id="cookieInfo"></div>
            </div>

            <!-- Action Buttons -->
            <div class="button-group">
                <button class="btn btn-primary" id="convertBtn" onclick="startConversion()" disabled>
                    Convert to MIDI
                </button>
                <button class="btn btn-cancel" id="cancelBtn" onclick="cancelConversion()" disabled>
                    Cancel
                </button>
            </div>

            <!-- Progress Bar -->
            <div class="progress-section" id="progressSection">
                <div class="progress-header">
                    <span class="progress-text" id="progressText">Processing files...</span>
                    <span class="progress-count" id="progressCount">0 / 0</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <!-- Results -->
            <div class="card results-section" id="resultsSection">
                <div class="card-title">üìä Processing Log</div>
                <div class="log-container" id="processingLog"></div>
                <button class="btn-download" id="downloadBtn" onclick="downloadMIDI()">
                    ‚¨áÔ∏è Download MIDI Files
                </button>
            </div>
        </div>

        <script>
            let selectedFiles = [];
            let cookieFile = null;
            let settingsExpanded = true;
            let isProcessing = false;
            let videoTitles = [];
            let isFetchingTitles = false;
            let debugVisible = false;

            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');
            const zipOutputCheckbox = document.getElementById('zipOutput');
            const zipFilenameInput = document.getElementById('zipFilenameInput');
            const keepMp3Checkbox = document.getElementById('keepMp3');
            const includeMp3Checkbox = document.getElementById('includeMp3');
            const mp3IncludeOption = document.getElementById('mp3IncludeOption');
            const enableMaxNotesCheckbox = document.getElementById('enableMaxNotes');
            const maxNotesInput = document.getElementById('maxNotes');

            // Debug Functions
            function toggleDebug() {
                debugVisible = !debugVisible;
                const section = document.getElementById('debugSection');
                section.style.display = debugVisible ? 'block' : 'none';
                if (debugVisible) {
                    refreshDebug();
                }
            }

            function refreshDebug() {
                try {
                    const debugOutput = document.getElementById('debugOutput');
                    const youtubeUrls = document.getElementById('youtubeUrls').value.trim();
                    const convertBtn = document.getElementById('convertBtn');

                    // Split URLs by line
                    const urlLines = youtubeUrls.split('\\n').filter(line => line.trim());

                    const debugInfo = {
                        timestamp: new Date().toISOString(),

                        youtubeUrls: {
                            raw: youtubeUrls,
                            lines: urlLines,
                            count: urlLines.length,
                            isEmpty: !youtubeUrls,
                            hasContent: !!youtubeUrls
                        },

                        selectedFiles: {
                            count: selectedFiles.length,
                            hasFiles: selectedFiles.length > 0,
                            files: selectedFiles.map(f => ({
                                name: f.name,
                                size: f.size + ' bytes',
                                type: f.type || 'unknown'
                            }))
                        },

                        cookieFile: {
                            loaded: cookieFile !== null,
                            name: cookieFile ? cookieFile.name : null
                        },

                        buttonState: {
                            isProcessing: isProcessing,
                            currentlyDisabled: convertBtn.disabled,
                            shouldBeEnabled: (youtubeUrls || selectedFiles.length > 0) && !isProcessing,
                            reason: getButtonDisabledReason(youtubeUrls, selectedFiles.length, isProcessing)
                        },

                        checks: {
                            hasYoutubeUrls: !!youtubeUrls,
                            hasFiles: selectedFiles.length > 0,
                            hasAnyInput: !!(youtubeUrls || selectedFiles.length > 0),
                            notProcessing: !isProcessing,
                            allConditionsMet: !!(youtubeUrls || selectedFiles.length > 0) && !isProcessing
                        }
                    };

                    debugOutput.textContent = JSON.stringify(debugInfo, null, 2);
                } catch (e) {
                    const debugOutput = document.getElementById('debugOutput');
                    debugOutput.textContent = 'Error generating debug info: ' + e.message;
                }
            }

            function getButtonDisabledReason(urls, filesCount, processing) {
                if (processing) return 'Currently processing';
                if (!urls && filesCount === 0) return 'No YouTube URLs or files provided';
                if (urls && filesCount === 0) return 'Should be ENABLED (has URLs)';
                if (!urls && filesCount > 0) return 'Should be ENABLED (has files)';
                return 'Should be ENABLED';
            }

            function setupDebugAutoRefresh() {
                if (debugVisible) {
                    setTimeout(refreshDebug, 100);
                }
            }

            async function fetchVideoTitles(urls) {
                if (urls.length === 0) return [];

                isFetchingTitles = true;
                try {
                    const result = await google.colab.kernel.invokeFunction('notebook.FetchYouTubeTitles', [urls], {});
                    videoTitles = result.data['application/json'];
                    return videoTitles;
                } catch (e) {
                    console.error('Error fetching titles:', e);
                    return urls.map(() => 'Unable to fetch title');
                } finally {
                    isFetchingTitles = false;
                }
            }

            // Toggle ZIP filename input when checkbox is clicked
            zipOutputCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    zipFilenameInput.classList.add('visible');
                } else {
                    zipFilenameInput.classList.remove('visible');
                }
            });

            // Toggle MP3 include option when keepMp3 is clicked
            keepMp3Checkbox.addEventListener('change', function() {
                if (this.checked) {
                    mp3IncludeOption.classList.add('visible');
                } else {
                    mp3IncludeOption.classList.remove('visible');
                    // Uncheck includeMp3 if keepMp3 is unchecked
                    includeMp3Checkbox.checked = false;
                }
            });

            // When includeMp3 is checked, auto-check and disable keepMp3
            includeMp3Checkbox.addEventListener('change', function() {
                if (this.checked) {
                    keepMp3Checkbox.checked = true;
                    keepMp3Checkbox.disabled = true;
                    keepMp3Checkbox.parentElement.classList.add('disabled');
                } else {
                    keepMp3Checkbox.disabled = false;
                    keepMp3Checkbox.parentElement.classList.remove('disabled');
                }
            });

            // Toggle max notes input when checkbox is clicked
            enableMaxNotesCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    maxNotesInput.disabled = false;
                } else {
                    maxNotesInput.disabled = true;
                }
            });

            uploadZone.addEventListener('click', () => fileInput.click());

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadZone.style.borderColor = '#818cf8';
                uploadZone.style.background = '#1e293b';
            });

            uploadZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadZone.style.borderColor = '#475569';
                uploadZone.style.background = '#0f172a';
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadZone.style.borderColor = '#475569';
                uploadZone.style.background = '#0f172a';
                handleFiles(e.dataTransfer.files);
            });

            fileInput.addEventListener('change', (e) => {
                handleFiles(e.target.files);
            });

            async function handleFiles(files) {
                selectedFiles = Array.from(files);
                const fileInfo = document.getElementById('fileInfo');

                if (selectedFiles.length > 0) {
                    fileInfo.innerHTML = '<strong>‚úì Selected:</strong> ' +
                        selectedFiles.map(f => f.name).join(', ');
                    fileInfo.style.display = 'block';

                    files.forEach(file => {
                        uploadFileToColab(file);
                    });
                } else {
                    fileInfo.style.display = 'none';
                }

                await updateFileNamingSection();
                enableConvertButton();
            }

            let urlInputTimeout;
            document.getElementById('youtubeUrls').addEventListener('input', function() {
                // Debounce the title fetching
                clearTimeout(urlInputTimeout);
                urlInputTimeout = setTimeout(async () => {
                    const youtubeUrls = this.value.trim();
                    const urlList = youtubeUrls ? youtubeUrls.split('\\n').filter(u => u.trim()) : [];

                    if (urlList.length > 0 && !isFetchingTitles) {
                        videoTitles = await fetchVideoTitles(urlList);
                    } else if (urlList.length === 0) {
                        videoTitles = [];
                    }

                    updateFileNamingSection();
                }, 800); // Wait 800ms after user stops typing

                enableConvertButton();
            });

            async function updateFileNamingSection() {
                const youtubeUrls = document.getElementById('youtubeUrls').value.trim();
                const urlList = youtubeUrls ? youtubeUrls.split('\\n').filter(u => u.trim()) : [];
                const totalFiles = urlList.length + selectedFiles.length;

                const section = document.getElementById('fileNamingSection');
                const list = document.getElementById('fileNamingList');

                // Show section only if multiple files
                if (totalFiles > 1) {
                    section.style.display = 'block';
                    list.innerHTML = '';

                    // Add inputs for YouTube URLs
                    urlList.forEach((url, index) => {
                        const item = document.createElement('div');
                        item.className = 'file-naming-item';

                        // Use fetched title or show "Fetching..." while loading
                        let placeholder;
                        if (videoTitles && videoTitles[index]) {
                            placeholder = videoTitles[index];
                        } else if (isFetchingTitles) {
                            placeholder = 'Fetching title...';
                        } else {
                            placeholder = url.length > 50 ? url.substring(0, 47) + '...' : url;
                        }

                        // Escape HTML entities for placeholder
                        const escapedPlaceholder = placeholder
                            .replace(/&/g, '&amp;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');

                        item.innerHTML = `
                            <label>YouTube Video ${index + 1}</label>
                            <input type="text" class="file-custom-name" data-type="youtube" data-index="${index}"
                                   placeholder="${escapedPlaceholder}">
                        `;
                        list.appendChild(item);
                    });

                    // Add inputs for uploaded files
                    selectedFiles.forEach((file, index) => {
                        const item = document.createElement('div');
                        item.className = 'file-naming-item';

                        const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
                        const escapedFileName = fileNameWithoutExt
                            .replace(/&/g, '&amp;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#39;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;');

                        item.innerHTML = `
                            <label>Uploaded File ${index + 1}</label>
                            <input type="text" class="file-custom-name" data-type="upload" data-index="${index}"
                                   placeholder="${escapedFileName}">
                        `;
                        list.appendChild(item);
                    });
                } else {
                    section.style.display = 'none';
                }
            }

            document.getElementById('cookieInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    cookieFile = file;
                    const cookieInfo = document.getElementById('cookieInfo');
                    cookieInfo.innerHTML = '<strong>‚úì Loaded:</strong> ' + file.name;
                    cookieInfo.style.display = 'block';
                    uploadCookieToColab(file);
                }
            });

            function uploadFileToColab(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result.split(',')[1];
                    google.colab.kernel.invokeFunction('notebook.UploadFile', [file.name, content], {});
                };
                reader.readAsDataURL(file);
            }

            function uploadCookieToColab(file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result.split(',')[1];
                    google.colab.kernel.invokeFunction('notebook.UploadCookie', [file.name, content], {});
                };
                reader.readAsDataURL(file);
            }

            function enableConvertButton() {
                const youtubeUrls = document.getElementById('youtubeUrls').value.trim();
                const hasFiles = selectedFiles.length > 0;

                const btn = document.getElementById('convertBtn');
                btn.disabled = !((youtubeUrls || hasFiles) && !isProcessing);

                // Auto-refresh debug if visible
                setupDebugAutoRefresh();
            }

            function toggleSettings() {
                settingsExpanded = !settingsExpanded;
                const content = document.getElementById('settingsContent');
                const icon = document.getElementById('toggleIcon');

                if (settingsExpanded) {
                    content.style.display = 'block';
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    content.style.display = 'none';
                    icon.style.transform = 'rotate(-90deg)';
                }
            }

            function addLogEntry(message, type = 'info') {
                const log = document.getElementById('processingLog');
                const timestamp = new Date().toLocaleTimeString();
                let color = '#68d391';
                if (type === 'error') color = '#fc8181';
                if (type === 'warning') color = '#fbbf24';

                log.innerHTML += `<span style="color: ${color};">[${timestamp}] ${message}</span><br>`;
                log.scrollTop = log.scrollHeight;
            }

            function updateOverallProgress(current, total) {
                const section = document.getElementById('progressSection');
                const bar = document.getElementById('progressBar');
                const count = document.getElementById('progressCount');
                const text = document.getElementById('progressText');

                section.style.display = 'block';
                const percentage = (current / total) * 100;
                bar.style.width = percentage + '%';
                count.textContent = current + ' / ' + total;
                text.textContent = current < total ? 'Processing files...' : 'Complete!';
            }

            function startConversion() {
                try {
                    isProcessing = true;

                    const convertBtn = document.getElementById('convertBtn');
                    const cancelBtn = document.getElementById('cancelBtn');
                    convertBtn.disabled = true;
                    cancelBtn.disabled = false;

                    document.getElementById('resultsSection').style.display = 'block';
                    document.getElementById('processingLog').innerHTML = '';
                    document.getElementById('downloadBtn').style.display = 'none';
                    document.getElementById('progressSection').style.display = 'none';

                    addLogEntry('üîÑ Initializing conversion...');

                    // Collect custom file names
                    const customFileNames = [];
                    document.querySelectorAll('.file-custom-name').forEach(input => {
                        customFileNames.push(input.value.trim());
                    });

                    const settings = {
                        youtubeUrls: document.getElementById('youtubeUrls').value,
                        customTitle: document.getElementById('customTitle').value,
                        customFileNames: customFileNames,
                        modelChoice: document.getElementById('modelChoice').value,
                        chunkDur: parseFloat(document.getElementById('chunkDur').value),
                        maxNotes: parseFloat(document.getElementById('maxNotes').value),
                        enableMaxNotes: document.getElementById('enableMaxNotes').checked,
                        startTime: parseFloat(document.getElementById('startTime').value),
                        endTime: parseFloat(document.getElementById('endTime').value),
                        zipOutput: document.getElementById('zipOutput').checked,
                        zipFilename: document.getElementById('zipFilename').value,
                        keepMp3: document.getElementById('keepMp3').checked,
                        includeMp3: document.getElementById('includeMp3').checked
                    };

                    addLogEntry('üì§ Sending conversion request to backend...');
                    console.log('Settings:', settings);

                    google.colab.kernel.invokeFunction('notebook.Convert', [settings], {})
                        .then(() => {
                            console.log('Conversion function invoked successfully');
                        })
                        .catch((error) => {
                            console.error('Error invoking conversion:', error);
                            addLogEntry('‚ùå Error starting conversion: ' + error.message, 'error');
                            isProcessing = false;
                            convertBtn.disabled = false;
                            cancelBtn.disabled = true;
                            enableConvertButton();
                        });
                } catch (error) {
                    console.error('Error in startConversion:', error);
                    addLogEntry('‚ùå JavaScript error: ' + error.message, 'error');
                    isProcessing = false;
                    document.getElementById('convertBtn').disabled = false;
                    document.getElementById('cancelBtn').disabled = true;
                    enableConvertButton();
                }
            }

            function cancelConversion() {
                google.colab.kernel.invokeFunction('notebook.CancelConversion', [], {});
                document.getElementById('cancelBtn').disabled = true;
            }

            function downloadMIDI() {
                google.colab.kernel.invokeFunction('notebook.DownloadMIDI', [], {});
            }

            function onConversionComplete(filename, isZip) {
                isProcessing = false;
                addLogEntry('‚úÖ All conversions complete!');
                if (isZip) addLogEntry('üì¶ Files packaged in ZIP: ' + filename);
                document.getElementById('downloadBtn').style.display = 'block';
                document.getElementById('cancelBtn').disabled = true;
                enableConvertButton();
            }

            function onConversionError(error) {
                isProcessing = false;
                addLogEntry('‚ùå Error: ' + error, 'error');
                document.getElementById('cancelBtn').disabled = true;
                enableConvertButton();
            }

            function onConversionCancelled() {
                isProcessing = false;
                addLogEntry('üõë Conversion cancelled by user', 'warning');
                document.getElementById('convertBtn').disabled = false;
                document.getElementById('cancelBtn').disabled = true;
                enableConvertButton();
            }

            function updateProgress(message, type = 'info') {
                addLogEntry(message, type);
            }
        </script>
    </body>
    </html>
    """

    display(HTML(html_content))

def handle_file_upload(filename, content):
    """Handle file upload from JavaScript."""
    global uploaded_files
    try:
        import base64
        file_data = base64.b64decode(content)
        with open(filename, 'wb') as f:
            f.write(file_data)
        uploaded_files[filename] = file_data
        print(f"‚úÖ File uploaded: {filename}")
    except Exception as e:
        print(f"‚ùå Upload error: {e}")

def clear_uploaded_files():
    """Clear the uploaded files dict."""
    global uploaded_files
    uploaded_files.clear()
    print("üóëÔ∏è Cleared previous uploads")

def handle_cookie_upload(filename, content):
    """Handle cookie file upload from JavaScript."""
    global converter
    try:
        import base64
        file_data = base64.b64decode(content)
        cookie_path = Path(filename)
        with open(cookie_path, 'wb') as f:
            f.write(file_data)
        converter.set_cookie_file(str(cookie_path))
        print(f"‚úÖ Cookie file uploaded: {filename}")
    except Exception as e:
        print(f"‚ùå Cookie upload error: {e}")

# --------------- Register Callbacks ---------------

output.register_callback('notebook.UploadFile', handle_file_upload)
output.register_callback('notebook.ClearFiles', clear_uploaded_files)
output.register_callback('notebook.UploadCookie', handle_cookie_upload)
output.register_callback('notebook.Convert', run_conversion)
output.register_callback('notebook.CancelConversion', cancel_conversion_handler)
output.register_callback('notebook.DownloadMIDI', download_midi_file)
output.register_callback('notebook.FetchYouTubeTitles', fetch_youtube_titles)

# --------------- Run ---------------

show_ui()

